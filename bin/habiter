#!/usr/bin/env ruby
# Habiter: simple habit tracking
# add or update habit:
#   'habiter did clean_room'
# view habit graph:
#   'habiter graph'

require 'yaml'
require 'optparse'

# Stolen from ActiveSupport
class Time
  def to_date
    ::Date.new(year, month, day)
  end unless method_defined?(:to_date)
end

class String
  def colorize(color_code)
    "\e[#{color_code}m#{self}\e[0m"
  end
end

  
def habiter_initialize
  @habiter_file = File.expand_path('~/.habiter.yaml')
  begin
    @habits = YAML::load_file(@habiter_file)
  rescue
    File.open(@habiter_file, 'w').close()
  end
  @habits = {} unless @habits
end

options = {}
optparse = OptionParser.new do |opts|
  opts.banner = 
    "Usage:
    habiter did your_habit
    habiter log"
  options[:verbose] = false
  opts.on('-v', '--verbose', "Show weekday letters for log") do
    options[:verbose] = true
  end
end

# Record that somebody did something. Expects an unadulterated
# args array, from which it takes the second and optionally third
# parameters
def did(args)
  key = args[1]
  new_record = (args.length > 2) ? {Time.now => args[2]} : Time.now
  if not @habits.has_key?(key)
    print "#{key} is not a habit yet. create and complete it? (y/n) "
    if STDIN.gets.chomp == 'y'
      @habits[key] = [new_record]
    end
  else
    @habits[key] << new_record
  end
  File.open(@habiter_file, 'w') do |f|
    YAML.dump(@habits, f)
  end
end


def normalize_time(time)
  if time.is_a? Hash
    time = time.keys.first
  end
  if time.is_a? Time
    time.to_date
  elsif time.is_a? Date
    time
  end
end

# Output this YAML datastore as normalized CSV for processing by
# whatever wants it
def dump(options={})
  cols = @habits.length
  @habits.each do |habit, times|
    times.collect! do |time|
      this_time = normalize_time(time)
      bytime[time] 
    end
  end
end

# Display a basic visualization of recent task completion
def log(options={})
  options[:days] = 28 unless options[:days]
  name_column_width = @habits.max {|a,b| a[0].length <=> b[0].length}[0].length
  day = Date.today - options[:days]
  if options[:verbose]
    print " " * (name_column_width + 2)
    (0..options[:days]).each do |i|
        print (day + (i)).strftime('%a')[0].chr.swapcase.colorize(37)
    end
    puts
  end
  daily_counts = Array.new(29, 0)
  @habits.each do |habit, times|
    day = Date.today - (options[:days])
    print (sprintf("%#{name_column_width}s ", habit) + "|").colorize(37)
    times.collect! do |time|
      normalize_time(time)
    end
    done_in_last_28, week, pre_week = 0, 0, 0
    (0..options[:days]).each do |i|
      if times.include? day
        print "+".colorize(47)
        daily_counts[i] += 1
        done_in_last_28 += 1
        pre_week += 1 unless i >= 20
        week += 1 unless i < 20
      else
        print "-".colorize(37)
      end
      day += 1
    end
    if ((pre_week / 3) > (week + 2))
      print "|".colorize(37)
      print "(#{done_in_last_28}/28)".colorize(31)
    else
      print "|".colorize(37)
      print "(#{done_in_last_28}/28)".colorize(32)
    end
    puts
  end
  if options[:verbose]
    print " " * (name_column_width + 2)
    (0..options[:days]).each do |i|
        print (daily_counts[i] > 0) ? daily_counts[i] : " "
    end
    puts
  end
end

optparse.parse!

habiter_initialize()

if ARGV[0] == 'did'
  did(ARGV)
elsif ARGV[0] == 'log'
  log(options)
elsif ARGV[0] == 'dump'
  dump(options)
end
